	/**
	 * Provides a String evaluation and 2v1 comparison algorithm for finding relevant String based search results.
	 * @author Brian Groenke
	 *
	 */
	private static class StringCrawler extends DatabaseCrawler<String> {

		/*
		 * Relevance threshold of 4 prevents most instances of false positives based on common
		 * words...
		 */
		private final int RELEVANCE_THRESHOLD = 4;
		private final String[] COMMON = new String[] { "the", "a", "of", "an",
				"and", "but" };

		protected StringCrawler(String a) {
			super(a);
		}

		@Override
		public int compare(String a, String b) {
			String query = removeDoubleWhitespace(this.query.toLowerCase());
			a = removeDoubleWhitespace(a.toLowerCase());
			b = removeDoubleWhitespace(b.toLowerCase());

			int aptn = 0, bptn = 0;
			String[] qpts = query.split("\\s+");
			String[] apts = a.split("\\s+");
			String[] bpts = b.split("\\s+");
			for (String s : qpts) {
				for (String as : apts) {
					if (as.equals(s) && Arrays.binarySearch(COMMON, s) < 0) {
						aptn += as.length();
					}
				}
				for (String bs : bpts) {
					if (bs.equals(s) && Arrays.binarySearch(COMMON, s) < 0) {
						bptn += bs.length();
					}
				}
			}

			// This gets very confusing...
			char[] qcs = query.toCharArray();
			char[] acs = a.toCharArray();
			char[] bcs = b.toCharArray();
			for (int ql = 0, al = 0, bl = 0; ql < query.length()
					&& al < a.length() && bl < b.length(); ql++, al++, bl++) {
				boolean qhold = Character.isWhitespace(qcs[ql]);
				boolean ahold = Character.isWhitespace(acs[al]);
				boolean bhold = Character.isWhitespace(bcs[bl]);
				if (qhold && ahold && bhold) {
					continue;
				} else {
					if (qcs[ql] == acs[al]) {
						aptn++;
					}
					if (qcs[ql] == bcs[bl]) {
						bptn++;
					}
				}
				if (qhold) {
					ql--;
				}
				if (ahold) {
					al--;
				}
				if (bhold) {
					bl--;
				}
			}

			if (aptn > bptn) {
				return 1;
			} else if (aptn == bptn) {
				return 0;
			} else {
				return -1;
			}
		}

		// Same algorithm (copy/pasted) as compare with b var removed. In
		// hindsight, the base algorithm should be extracted to a separate
		// method... TODO ?
		@Override
		public boolean isRelevant(String a) {
			String query = removeDoubleWhitespace(this.query.toLowerCase());
			a = removeDoubleWhitespace(a.toLowerCase());

			int aptn = 0;
			String[] qpts = query.split("\\s+");
			String[] apts = a.split("\\s+");
			for (String s : qpts) {
				for (String as : apts) {
					if (as.equals(s) && Arrays.binarySearch(COMMON, s) < 0) {
						aptn += as.length();
					}
				}
			}

			// This gets very confusing...
			char[] qcs = query.toCharArray();
			char[] acs = a.toCharArray();
			for (int ql = 0, al = 0; ql < query.length() && al < a.length(); ql++, al++) {
				boolean qhold = Character.isWhitespace(qcs[ql]);
				boolean ahold = Character.isWhitespace(acs[al]);
				if (qhold && ahold) {
					continue;
				} else {
					if (qcs[ql] == acs[al]) {
						aptn++;
					}
				}
				if (qhold) {
					ql--;
				}
				if (ahold) {
					al--;
				}
			}
			return aptn >= RELEVANCE_THRESHOLD;
		}

		/**
		 * Removes double whitespace from the String to prevent the algorithm from getting messed up.
		 * @param str
		 * @return
		 */
		private String removeDoubleWhitespace(String str) {
			StringBuilder sb = new StringBuilder();
			boolean lsw = false;
			for (char c : str.toCharArray()) {
				if (!lsw) {
					sb.append(c);
				}
				if (Character.isWhitespace(c) && (c != '\n' && c != '\r')) {
					lsw = true;
				} else if (lsw) {
					lsw = false;
					sb.append(c);
				}
			}

			return sb.toString();
		}

	}